<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <title>L04 - Rezgő motor és az alkalmazás életciklusa</title>

    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://code.jquery.com/ui/1.11.1/themes/ui-lightness/jquery-ui.css" />
    <link rel="stylesheet" href="/static/css/stsheet.css">

    <style>
        /* Original src: https://gist.github.com/grevory/5369438 */
        .thumbnail.with-caption {
            background: #f5f5f5;
            width: 75%;
            margin: 20px auto;
        }
        .thumbnail.with-caption p {
            margin: 0;
            padding-top: 0.5em;
            text-align: center;
        }
    </style>

    <!-- bootstrap stuff -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="https://code.jquery.com/ui/1.11.1/jquery-ui.min.js"></script>


    <script type="text/javascript">
        function pageInit() {
            $('div.help-container').each(function () {
                var $dialog = $(this);
                var id = $dialog.attr('id');
                var $source = $('button.help-link[data-target="' + id + '"]');

                $source.click(function () {
                    $dialog.dialog('open');
                });

                $dialog.dialog({
                    autoOpen: false,
                    height: 'auto',
                    minHeight: 0,
                    maxHeight: 600,
                    width: 'auto',
//                    maxWidth: 600, // doesn't work if width: 'auto' is also set :(
                    show: 'slideDown',
                    hide: 'slideUp',
//                    modal: true,
                    position: {my: "center top", at: "center bottom", of: $source},
                    open: function (event, ui) {
                        //hide titlebar. src: http://stackoverflow.com/a/25629837/
                        $(this).parent().children('.ui-dialog-titlebar').hide();

                        // src: http://stackoverflow.com/a/7924361/
                        $(document).mouseup(function(e) {
                            var clicked = $(e.target); // get the element clicked
                            if (clicked.is($dialog)
                                    || clicked.parents().is($dialog)
                                    || clicked.is('.ui.dialog-titlebar')) {
                                return; // click happened within the dialog, do nothing here
                            } else { // click was outside the dialog, so close it
                                $dialog.dialog("close");
                            }
                        });
                    }
                });
            });

            $('button.help-link[data-target]').click(function (event) {
                event.preventDefault();
                var targetId = $(this).data('target');
                var $target = $('#' + targetId);
                $target.dialog('open');
            });
        }
    </script>

</head>
<body>

<header data-include="/include/header.html"></header>

<div class="container">

    <h1>4. lecke
        <small>Rezgő motor és az alkalmazás életciklusa</small>
    </h1>
	<hr/>
    <section id="lesson-contents">
        <h2>A lecke tartalma</h2>
        <p>Ebben a leckében használni fogjuk a telefon rezgő motorját, illetve egy kicsit mélyebben
            megismerkedünk az androidos alkalmazások működésével.</p>
    </section>

    <section id="import-project">
        <h2>Projekt importálása</h2>
        <p>Az előzőekhez hasonlóan ebben a leckében is egy előkészített projektben fogunk dolgozni.
            Ezen a linken (TODO) megtaláljátok az L04-Rezeg.zip fájlt,
            ezt töltsétek le, csomagoljátok ki az eddigi projektek mellé.</p>
        <p>Majd importáljátok a projektet az Android Studioba
            (<em>File -> Close Project</em>, majd <em>Import Project</em>).
            Ha véletlenül elakadnátok, akkor követhetitek az <a href="./l03.html#import-project" target="_blank"> előző lecke (L03)
            projekt importálásáról szóló részét.</a></p>
        <div class="imgstore">
            <img src="/static/img/l03/03_closeProject.png" class="center-block" />
            <img src="/static/img/l03/04_importProject.png" class="center-block" />
            <img src="/static/img/l03/05_findProjectFolder.png" class="center-block" />
        </div>
        <p>Ha mindent jól csináltál, akkor a programot le is tudod futtatni
            (<img src="/static/img/l03/07_inlineRun.png" style="display: inline-block; margin: 0;" />).
            Az alkalmazásunk layout-ja azonban egyelőre üres.</p>
    </section>

    <section id="task_1">
        <h3 class="task">1. feladat: rezgés bekapcsolása</h3>
        <p>Első lépésként készítünk egy egyszerű alkalmazást, ami egy gomb lenyomásakor
            bekapcsolja a telefon rezgő motorját (avagy Vibrator angolul).</p>
        <p>Ehhez:</p>
        <ol>
            <li>Létre kell hoznunk egy gombot a layout szerkesztőben</li>
            <li>Meg kell írnunk egy onClick függvény vázát (legyen a neve: rezegOnClick),
                ami a gomb lenyomására fog lefutni</li>
            <li>Be kell állítanunk a gombunk onClick tulajdonságát, hogy az új függvényünket hívja meg</li>
            <li>Létre kell hozunk egy Vibrator típusú változót (legyen a neve: rezgoMotor)</li>
            <li>Hozzá kell rendelnünk a rezgoMotor változót a telefonunk rezgő motorjához</li>
            <li>Be kell fejeznünk a rezegjOnClick függvényt, hogy aktiválja a rezgést</li>
        </ol>

        <h4 class="task">1.1 Gomb lerakása</h4>
        <p>Mint bizonyára emlékezhettek az előző leckéből, az alkalmazásunk kinézetét a
            Layout szerkesztőben tudjuk megszabni. A layout szerkesztőt az
            <em>app -> res -> layout -> activity_main.xml</em>
            megnyitásával éritek el. Az új gombot húzzátok mondjuk a
            képernyő közepére. A felirata legyen: <code>rezegj!</code>.
            Nyugodtan átállíthatjátok a szöveg méretét/színét stb.</p>

        <h4 class="task">1.2 rezegjOnClick váza</h4>
        <p>Remélhetőleg ismerős az alábbi <strong>függvény</strong>, amely <code>rezegjOnClick</code> névre hallgat.
            A függvény törzse a komment lesz, ahol perjelek mögött a komment
            emlékeztet minket: a függvényünk egyelőre üres.</p>
        <pre>
public void rezegjOnClick(View v) {
	//TODO Ezt itt még be kell fejezni
}</pre>
        <p>A függvényt a <span class="todo">TODO 1.2</span> helyére írd be! Figyeld meg, hogy egy szintre került a többi,
            már meglévő függvénnyel (azaz a sor ugyan annyival kezdődik beljebb, mint a függvények). Ezt nyugodtan meg is jegyezhetjük: a Java 
			nyelvben a függvények <em>mindig</em> egy szinten helyezkednek el.</p>

        <h4 class="task">1.3 Gomb onClick tulajdonsága</h4>
        <p>Ahhoz, hogy a gomb lenyomásakor a függvényünk lefusson (meghívásra kerüljön),
            át kell állítanunk a gomb “onClick” tulajdonságát a layout
            editorban az új függvényünkre (TODO kép).</p>

        <h4 class="task">1.4 Változó létrehozása, rezgő motor hozzárendelése</h4>
        <p>A vibrátor motor eléréséhez létre kell hoznunk egy változót. Előfordulhat, hogy csodálkoztok: Miért is van szükség egy változó létrehozására,
            amikor mi csak meg szeretnénk kérni a telefonunkat, hogy rezegjen egy picit?
            Gondoljatok így a helyzetre: <br/>
            A telefon rezgő motorja egy picit olyan, mint egy gomb, amit elhelyeztünk a
            layout szerkesztővel, csak ezt a telefon gyártója rakta bele a telefonba.
            Mi tudjuk, hogy létezik, de a Java kódunknak ennél több kell: Létre kell hozunk
            egy <code>Vibrator</code> típusú változót, majd hozzá kell rendelnünk a
            telefonunkban elhelyezkedő hardverhez. (Emlékezz, a <code>Button</code> típusú változónkhoz
            is hozzárendeltünk egy-egy gombot, megadott <code>id</code> azonosítóval).</p>
        <p>Tehát hozzunk létre egy Vibrator típusú változót <span class="todo">TODO 1.4a</span></p>
        <pre>Vibrator rezgoMotor;</pre>
        <p>A hozzárendelést az <code>onCreate</code> függvény utolsó sorában <span class="todo">TODO 1.4b</span>
            az alábbi paranccsal tehetjük meg:</p>
        <pre>rezgoMotor = (Vibrator) getSystemService(VIBRATOR_SERVICE);</pre>
		<p>Ugye hogy ez mennyire hasonlít ahhoz, amit a gomboknál csináltunk az előző lecke alkalmával?</p>
		<pre>gomb = (Button) findViewById(R.id.gomb1); // ez a sor csak minta, ne írd be</pre>

        <h4 class="task">1.5 Rezgés aktiválása</h4>
        <p>Ezen a ponton rendelkezünk egy <code>Vibrator</code> <strong>osztályú</strong> változóval.
            A <code>Vibrator</code> osztályú változóknak pedig több hasznos <em>belső függvény</em>ük is van.</p>

        <div class="misc-info">
            <p>A jövőben az olyan összetett típusokat, amik saját belső függvényekkel
                rendelkeznek, sokszor osztályoknak fogjuk hívni. Így különböztetjük meg a
                primitív típusokat (egész számok: <code>int</code>, karakterek: <code>char</code>,
                bool változók: <code>boolean</code>, lebegőpontos számok: <code>float</code> vagy <code>double</code>)
                az olyan típusoktól, mint pl. <code>Button</code>, <code>TextView</code>, <code>Vibrator</code>.</p>
		</div>         
		<p>Emlékeztetőül: a gombjaink belső függvényeit (mint pl. a <code>setText</code>)
            a következő módon hívhatjuk meg:</p>
        <pre>&lt;változó&gt;.&lt;függvényNeve&gt;(&lt;paraméterek&gt;);</pre>
        <p>pl.:</p>
        <pre>gomb1.setText(“új szöveg”);</pre>
        

        <p>A Vibrator osztály rendelkezik egy igen hasznos függvénnyel:</p>
        <pre>vibrate(milliszekundum)</pre>
        <p>A zárójelben lévő <strong>paraméter</strong> szabja meg, hogy hány ezred másodpercig rezegjen a telefonunk.</p>
        <p>Ezek alapján tudnál írni egy parancsot, ami meghívja/elindítja a <code>rezgoMotor</code> <code>vibrate</code>
            eljárását 1 másodperces paraméterrel (1000ms)?
            Írd a parancsot a rezegOnClick függvényünk törzsébe, hogy a gomb megnyomásakor
            induljon el <span class="todo">TODO 1.5</span>! Ha nagyon nincs ötlteted, akkor kattints a sor végén lévő gombra.
            <button data-target="help_1.5" class="help-link">Katt a megoldáshoz!</button></p>
        <div class="help-container" id="help_1.5">
			<p>Ugye <em> nem </em> csak lustaságból nézed meg a megoldást?!</p>
            <pre data-include="/include/l04/help_1.5.java"></pre>
        </div>
        <p>Ha minden jól sikerült, akkor most elindíthatod az alkalmazást!
            A telefonodon ha megnyomod a gombot, a készülék egy másodpercig rezegni fog.</p>
    </section>

    <section id="task_2">
        <h3 class="task">2. feladat: rezgés megszakítása</h3>
        <p>Próbáljuk megnövelni a rezgés idejét! Írd át a kódot, hogy 1000 ms helyett a
            készülék mondjuk 10000 ms-ig rezegjen!</p>
        <p>Itt érdemes egy kicsit elgondolkoznunk. Tíz másodperc sok idő, így előfordulhat,
            hogy a rezgést időnként még az idő lejárta előtt le akarjuk állítani? Gondolj például
            arra, amikor a telefonod csörgés közben szokott rezegni. A hívás fogadásakor a rezgés
            mindig azonnal leáll.</p>
        <p>Szerencsére a Vibrator osztály rendelkezik egy hasznos belső függvénnyel a jelenlegi rezgés
            leállítására is. Ez pedig a <code>cancel()</code> függvény. Figyeld meg, hogy itt nincs a függvénynek
            paramétere. A rezgés leállításához nincs szükség több információra.</p>
        <p>Az előző feladatok alapján hozz létre egy új gombot az előző alá, és érd el,
            hogy a megnyomásakor lefusson a <code>rezgoMotor</code> változó <code>cancel()</code> függvénye!</p>
        <p>Ehhez:</p>
        <ol>
            <li>Létre kell hoznunk egy gombot a layout szerkesztőben (mondjuk <code>állj!</code> felirattal)</li>
            <li>Meg kell írnunk egy onClick függvény vázát (legyen a neve: <code>alljOnClick</code>)</li>
            <li>Be kell állítanunk az új gombunk onClick tulajdonságát, hogy az <code>alljOnClick</code>
                függvényünket hívja meg</li>
            <li>Be kell fejeznünk az <code>alljOnClick</code> függvényt, hogy állítsa le a rezgést
                <button data-target="help_2.4" class="help-link">Katt a megoldáshoz!</button></li>
        </ol>
        <div class="help-container" id="help_2.4">
            <pre data-include="/include/l04/help_2.4.java"></pre>
        </div>
        <p>Ha mindent jól csináltál, akkor a programod futtatásakor most egy gombnyomásra
            elindíthatod vagy megállíthatod a telefonod rezgését. Ha a 10 másodperces időt
            túl rövidnek találod, nyugodtan átállíthatod mondjuk 5 percre (hány ezredmásodperc
            van 5 percben?). Végtelenített rezgést a lecke végén fogunk csinálni.</p>
    </section>

    <section id="activity-lifecycle">
        <h2>Az Activity életciklusa</h2>

        <h3 id="intro">Bevezetés</h3>
        <p>Ezen a ponton kénytelenek vagyunk kicsit jobban belemászni az alkalmazásunk és az activity-nk életciklusába.
            <button data-target="help_lifecycle" class="help-link">Mi is az az <em>életciklus</em>?</button>
            Miért? Erre láthatsz egy egyszerű demonstrációt:
        </p>
        <div class="help-container" id="help_lifecycle">
            <p>Valaminek az életciklusa a létezése során történő események sora.
                Például egy ember életciklusa: megszületik, oviba megy, suliba megy,
                leérettségizik, elkezd dolgozni, gyereke születik, nyugdíjba megy, meghal.
                Az alkalmazásunknak (illetve az Activityknek, lásd később) is van egy hasonló életciklusuk.
				****TODO**** tudunk valamit írni, ami kevésbé <em>lineáris</em>?</p>
        </div>
        <ul>
            <li>Állítsd a rezgés idejét jó hosszúra. Pl. maradhatunk 5 percnél</li>
            <li>Indítsd el az alkalmazást, és nyomd meg a “rezegj!” gombot. A telefonod elkezd rezegni</li>
            <li>Lépj ki az alkalmazásból (vissza gomb vagy home gomb)</li>
            <li>Mi történik?! A programot bezártuk, és a telefon még mindig rezeg! Mégis miért?
                És miért áll meg egy idő után?!</li>
        </ul>
        <p>A fenti probléma megértéséhez meg kell néznünk, hogy mi történik a programunk
            indításakor, bezárásakor stb.</p>


        <h3 id="what-is-an-activity">Mi is az az Activity?</h3>
        <p>Az Androidos alkalmazásaink alapvető építőköve az <strong>Activity</strong>. Az Activity biztosítja a
            kapcsolatot az Android rendszer és a felhasználók között. Kicsit olyan, mint egy
            Windows ablak, vagy egy Lazarus Form.</p>
        <p>Mi is dolgoztunk már Activitykkel, amikor az alkalmazásunk képernyőjének
            kinézetét szerkesztettük a Layout szerkesztővel, illetve amikor a mögötte rejlő Java kódot írtuk
            (pl. az onClick függvények). Az activity-nk neve <em>Main</em> volt, ezért is hívták a Java
            fájlunkat <code>MainActivity.java</code>-nak, a layoutot pedig <code>activity_main.xml</code>-nek.
            Fontos megérteni, hogy ez a kettő szorosan összefügg: layout nélkül nincs mi
            <em>megjelenjen</em>, és a Java kód nélkül nem <em>csinál</em> semmit az alkalmazásunk.</p>
        <div class="thumbnail with-caption" style="border: 2px double red;">
            <img src="/static/img/l03/13_JavaVsXML.png" class="center-block" />
            <p style="font-size: x-large;">Ez a kettő <strong>együtt</strong> alkotja az Activityt!</p>
        </div>
        <p>Fontos tudnunk, hogy egy Activity megfelelő működéséhez több ezer sorra van szükség!
            Szerencsére ezt nem nekünk kell megírnunk, a Google lelkes dolgozói megtették ezt
            helyettünk és megírtak egy általános Activity osztályt, amit mi csak
            kiegészítünk a saját pár sorunkkal.</p>
        <p>Vessünk most egy pillantást a Java kódra (MainActivity.java). Kattits a zölddel bekeretezett részekre,
		hogy megtudd: melyik sor mire való.</p>

        <div id="interactive-activity" class="interactive">
            <div id="panels-container" class="clearfix">
                <div class="interactive-panel">
                    <pre data-include="/include/l04/meta_activity.html"></pre>
                </div>
                <div class="interactive-panel">
                    <pre data-include="/include/l04/sample_activity.html"></pre>
                </div>
            </div>
            <div id="description">
                <p class="selected" data-iid="default">Kattints rá fent a zöld keretes részekre, hogy megtudd, mire valók!</p>
                <p data-iid="app-name">A package segít a programunk fájljaina rendszerezésében. Ez főként akkor segít, ha nagyobb programokat írunk, egyelőre nem kell vele foglalkozni.</p>
                <p data-iid="other-import">Az Android Studio ide sorolja fel, hogy hol találhatók a
                    különböző osztályok, amiket használunk az alkalmazásunkban. Többnyire ezzel sem kell foglalkoznunk.
                </p>
                <p data-iid="activity-name">Ez az activity-nk neve. Meg kell, hogy egyezzen a fájl nevével.</p>
				<p data-iid="activity-name">Az "extends Activity" rész garantálja, hogy megörököljük a Google által megírt
				általános Activity osztály összes kódját</p>
            </div>
        </div>

        <style type="text/css">
            .interactive {
                width: 100%;
                border: 2px solid #A4C739;
                padding: 5px;
            }

            #panels-container .interactive-panel {
                float: left;
                width: 50%;
            }

            .interactive-panel .ih {
                font-weight: bold;
                border: 1px solid #A4C739;
                display: inline-block;
            }

            .interactive-panel .ih.selected,
            div#description {
                -webkit-box-shadow: 0 0 20px 5px rgba(163,199,57,1);
                -moz-box-shadow:    0 0 20px 5px rgba(163,199,57,1);
                box-shadow:         0 0 20px 5px rgba(163,199,57,1);

                padding: 3px;
            }

            .interactive #description {
                /* mostly from bootstrap's 'pre' rule */
                background-color: #f5f5f5;
                border: 1px solid #ccc;
                border-radius: 4px;

                padding: 10px;
            }

            .interactive #description p {
                display: none;
            }

            .interactive #description p.selected {
                display: block;
            }
        </style>

        <script type="application/javascript">
            $('#panels-container').on('click', 'span.ih', function () {
                var iid = $(this).data('iid');
                $('span.ih').removeClass('selected');
                $('span.ih[data-iid="'+ iid + '"]').addClass('selected');

                $('.interactive #description p').hide();
                $('.interactive #description p[data-iid="' + iid + '"]').show();
            });
        </script>
        <h3 id="lifecycle-methods" class="task">3. feladat: Életciklus függvények</h3>
        <p>Az eredeti Activity osztálynak van pár érdekes függvénye, amivel eddig nem is találkoztunk, vagy csak nagyon
            érintőlegesen használtunk.
            Ezek olyan függvények, amit az Android rendszer automatikusan indít el adott
            pillanatban, ezzel jelezve az alkalmazásunknak (vagy épp az Activity-nknek),
            hogy bekövetkezett az adott életciklus eseménye ( &#8594; ezért <em>életciklus függvények</em>).</p>
        <p>Például nézzük meg a fenti interaktív példán az <code>onCreate</code> függvényt.</p>
        <p>Az Activitynk onCreate függvényét akkor futtatja a rendszer, amikor frissen elindítjuk az alkalmazást.
            Ez a legkorábbi pont, ahol bármittudunk csinálni az alkalmazás futása során. Érdemes ide rakni a
            változóink értékadását (pl.: layout komponensek: gombok, TextView-k, stb. illetve egyéb rendszerkomponensek:
            rezgő motor).</p>
        <p>Az elindulás (születés) nagyon fontos esemény, de koránt sem az egyetlen az Activitynk futása (élete) során.
            Nézzünk meg még kettőt, és rögtön használjuk is fel őket!</p>

        <h4 class="task">3.1 onPause</h4>
        <p>Az <code>onPause</code> függvényt akkor hívja a rendszer, amikor az alkalmazásunk futása valamiért felfüggesztésre
            kerül. Ez történik például a programunk bezárásakor (vissza gombbal, vagy a home gombbal).</p>
        <pre>
protected void onPause() {
    super.onPause();
    // ide írhatjuk a saját kódunkat...
}</pre>
        <p>Például írjuk be saját kódként azt a parancsot, ami leállítja a telefon rezgését!</p>
        <p>Ha most elindítjuk a programot, mit tapasztalunk a program bezárásakor? Abbamarad a rezgés?</p>

        <h4 class="task">3.2 onResume</h4>
        <p>Az <code>onResume</code> függvényt többnyire akkor hívja a rendszer, amikor az alkalmazás visszatér a
            felfüggesztett állapotból, de például lefut az első indulásnál is, az <code>onCreate</code> után (ld. később).</p>
        <pre>
protected void onResume() {
    super.onResume();
    // ide írhatjuk a saját kódunkat...
}</pre>
        <p>Például írjuk be saját kódként azt a parancsot, ami elindítja a rezgést 5 percig!</p>
        <p>Ha most elindítjuk a programot, mit tapasztalunk? Mi történik az első indításkor?
            És a program menüből történő újraindításánál?</p>

        <h4 class="task">3.3 feladat</h4>
        <p>Mi történik / melyik függvény hívódik meg ha a program futása közben&hellip;</p>
        <ol>
            <li>&hellip;lezárod a képernyőt (odalsó gombbal)?</li>
            <li>&hellip;újra kinyitod a képernyőt (felső/oldalsó gombbal)?</li>
            <li>&hellip;bezárod a programot a vissza gombbal?</li>
            <li>&hellip;bezárod a programot a home gombbal?</li>
            <li>&hellip;újraindítod a programot a menüből?</li>
            <li>&hellip;elforgatod a képernyőt?</li>
            <li>&hellip;érkezik egy bejövő hívás (Ne vedd fel, és ne kísérletezz ezzel,
                ha nem vagy benne biztos, hogy nem fog pénzbe kerülni ;) )?</li>
        </ol>
        <p>Töröld ki az <code>onPause</code> eljárásból a <code>rezgoMotor.cancel();</code> parancsot.
            Ha ezt követően újraindítod és bezárod a programot, akkor mennyi idő után marad abba a rezgés?</p>
        <p>A válaszokat küldd el nekünk emailben
            (<a href="mailto:dkrmg.android@gmail.com">dkrmg.android@gmail.com</a>)!</p>

        <h3>A teljes modell</h3>
        <p>Az alábbi leegyszerűsített ábra szemlélteti, hogy mi minden történik az alkalmazásunkkal élete folyamán.
            A színes buborékok az Activity lehetséges állapotai, a nyilak pedig a
            változásokkor futó függvényeket mutatják.</p>
        <img src="/static/img/l04/lifecycleSimplified.png" class="center-block" />
        <p>Egyes események következtében az alkalmazás állapotot válthat,
            ilyenkor pedig a megfelelő nyílon lévő függvény(ek) elindul(nak).</p>
        <p>Például nézzük meg a képernyő lezárását. Ilyenkor a <strong>Fut</strong> állapotból átlépünk a
            <strong>Felfüggesztve</strong> állapotba, és futtatásra kerül az <code>onPause</code> eljárás.</p>
        <p>Vegyük észre azt is, hogy a <strong>Felfüggesztve</strong> állapottól még több lépés vezet az
            alkalmazásunk végső haláláig. Az appunk több percig is sokszor a háttérben fut
            még mielőtt végleg elpusztul, ezért is folytatódott a remegés a vissza gomb megnyomása után.</p>
		<p>Az első sor: <code>super.<függvény neve>(<esetleges paraméterek>)</code> biztosítja, 
			hogy az a függvény is lefut, amit a Google-nél írak meg. Ez szükséges ahhoz, 
			hogy egyáltalán működni tudjon az alkalmazásunk.</p>
		<p>Az onCreate függvény az alkalmazás indításakor fut le, ezért is ide tettük a változóink 
			(pl gombok, rezgőmotor) értékadását. Így a program indulásakor már meg is találta a rezgoMotor 
			változó a telefonunk rezgő motorját.</p>

    </section>

    <section id="logging">
        <h3>Log, avagy naplózás</h3>
        <p>A fentiek alapján nagyjából rá lehet érezni, hogy mikor melyik életciklus-függvény fut le,
            de azért ez egy kicsit bizonytalan. Jó lenne pontosan látni, hogy melyik, mikor és
            milyen sorrendben fut le, nem? A rezgés elindulása és megállítása sok mindent elárult nekünk,
            de az Android rendszer ennél egy sokkal jobb eszközt is tartalmaz: A <em>LogCat</em> elnevezésű "rendszert",
            amivel rövid szöveges üzeneteket, értesítéseket tudunk kiíratni úgy, hogy azokat a gépen is láthassuk.</p>
        <img src="/static/img/l04/logcat_usage.png" class="center-block" />
        <p>Az ilyen log-üzenetek kiíratása pofon egyszerű, a kérdéses helyekre elég a következőt beírni:</p>
        <pre>Log.e("MainActivity", "...ide jöhet egy tetszőleges szöveg, ami meg fog jelenni...");</pre>
        <p>A fenti utasítás a következőképp épül fel: <br/>
            A <code>Log</code> osztálynak meghívjuk az <code>e</code> nevű belső függvényét, két szöveges paraméterrel:
            az első egy azonosító, hogy könnyebben megtaláljuk, hogy mi írta ki az üzenetet,
            a második pedig maga az üzenet.</p>
        <p>Próbáljuk is ki!</p>

        <h3 class="task">4. feladat: Jelenlegi működés logolása</h3>
        <p><em>A már meglévő életciklus-függvényekbe helyezzünk el egy-egy logoló utasítást,
            és ellenőrizzük, hogy mikor futnak!</em></p>

        <h4 class="task">4.1 feladat</h4>
        <ol>
            <li>Keressük meg az onCreate függvényünk záró kapcsos zárójelét, és elé szúrjunk be egy új sort.</li>
            <li>Ebbe a sorba írjuk be a következőt:
                <pre>Log.e("MainActivity", "onCreate fut");</pre></li>
            <li>Ugyan ezt végezzük el az onPause és az onResume függvényeinkben is, de figyeljünk
                oda, hogy mindegyikben a megfelelő üzenetet írassuk ki!</li>
        </ol>
        <p>Elvileg most már szépen naplózza az alkalmazásunk a saját működését.
            De hol tudjuk mi ezt a naplót megnézni?</p>

        <h4 class="task">4.2 feladat</h4>
        <ol>
            <li>Ha még nem tettük volna meg, futtassuk az alkalmazásunkat!</li>
            <li>Figyeljük meg, hogy miután elindult a telefonon az app, az Android Studio
                ablakában alul megjelenik egy kisebb ablak (panelnek is hívhatnánk), amiben
                eleinte semmi nincsen, majd egy idő után megjelenik benne pár sor (TODO kép).
                <br/>
                Ez az ablak a fentebb már említett LogCat rendszer megjelenítője, itt tudjuk
                visszanézni, hogy milyen üzeneteket naplózott az alkalmazásunk.</li>
            <li>Figyeljünk rá, hogy a kis ablak jobb felső sarkában ez szerepeljen:
                <code>app: hu.dkrmg.android.&lt;TODO packagename&gt;</code>! Ha nem ez van ott,
                akkor próbáljuk meg lenyitni a legördülő listát, és onnan válasszuk ki ezt a sort,
                vagy futtassuk újra az alkalmazást!</li>
        </ol>
        <p>Értelmezzük, hogy mit is látunk!
            (TODO a képre megjegyzések, valahogy így)</p>
        <img src="/static/img/l04/logcat_details.png" class="center-block" />
        <p>Ha megnézzük, hogy milyen sorrendben jelennek meg az üzenetek, láthatjuk, hogy milyen
            sorrendben futnak le a különböző életciklus-függvények.</p>


        <h3 class="task">5. feladat: Maradék életciklus függvények naplózása</h3>
        <p><em>Írjuk meg a maradék életciklus-függvényeket, és mindegyikben logoljuk,
            hogy éppen melyik fut, majd ellenőrizzük le a futásuk sorrendjét!</em></p>

        <h4 class="task">5.1 feladat</h4>
        <p>A MainActivity fájlban már létezik néhány életciklus függvény:
            <code>onCreate</code>, <code>onResume</code>, <code>onPause</code>.
            Ezek mellé írjuk meg még a következőket:
            <code>onStart</code>, <code>onStop</code>, <code>onDestroy</code>.
            Vigyázzunk, ezek csak a függvények nevei! Honnan tudhatjuk meg, hogy pontosan hogyan
            kell kinézniük (azaz mit kell írni a függvény neve elé, és utána, még a nyitó kapcsos zárójel előtt)?</p>
        <p>Erre több lehetőségünk is van, most nézzük meg a legkényelmesebbet.</p>

        <ol>
            <li>A már meglévő onResume függvényünk záró kapcsos zárójele után hagyjunk ki egy sort, majd
                kezdjük el beírni a következő megírandó függvényünk nevét: <code>onStart</code>.</li>
            <li>Ha az első 3-4 karakter leütáése után felnézünk a képernyőre, láthatjuk, hogy megjelent
                egy kis ablak, benne egy csomó olyan függvénnyel, aminek a nevében szerepel valahol
                az <code>onSt</code> karaktersorozat. Ezek közül már a mi feladatunk kiválasztani a
                nekünk szükségest, de ez nem okozhat gondot, hiszen csak egy olyan van, aminek
                a neve <code>onStart</code>.  TODO KÉPEK</li>
            <li>Győződjünk meg róla, hogy az van kijelölve (ha nem, a fel-le nyilakkal jelöljük ki!), mad
                nyomjunk ENTER-t! Ekkor az Android Studio megírja helyettünk, és még arra is figyel,
                hogy a kötelező <code>super.onRestart();</code> sor is szerepeljen benne.</li>
            <li>A fenti módszerrel írjuk meg a maradék két függvényt is: <code>onStop</code> és <code>onDestroy</code>!</li>
            <li>Az előző feladat alapján helyezzünk el ezekbe is egy-egy Log-sort, a megfelelő üzenettel</li>
            <li>Futtassuk a programot, és figyeljük a LogCat ablakot!</li>
        </ol>
    </section>

</div>

<footer data-include="/include/footer.html"></footer>

<script type="text/javascript">
    $(function () {
        loadIncludes();

        pageInit();
    });

    function loadIncludes() {
        $('[data-include]').each(function () {
            var $container = $(this);
            var path = $container.data('include');

            $.get(path, function (data) {
                $container.html(data);
            });
        });
    }
</script>

</body>
</html>
