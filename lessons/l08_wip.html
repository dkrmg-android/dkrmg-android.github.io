<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>L08 - Szótár (1) (DKRMG Android Szakkör)</title>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="//ajax.googleapis.com/ajax/libs/jqueryui/1.11.2/themes/smoothness/jquery-ui.css" />
    <link rel="stylesheet" href="/static/css/stsheet.css">
    <link href="//cdn.rawgit.com/noelboss/featherlight/master/release/featherlight.min.css"
        type="text/css" rel="stylesheet" title="Featherlight Styles" />
    <!-- bootstrap stuff -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jqueryui/1.11.2/jquery-ui.min.js"></script>
</head>
<body>
    <header data-include="/include/header.html"></header>
    <div class="container">
        <h1>
            8. lecke <small>Szótár (1)</small><p>
                <small>Online Android szakkör (DKRMG)</small><p>
        </h1>
        <hr/>

        <section id="lesson-intro">
            <h2>Egy kis bevezetés</h2>
            <p>
                Az első hét lecke elkészítése után nem túlzás azt mondani, hogy sikeresen vetted az Android
                programozás talán legnagyobb akadályait. Feltelepítetted az Android Studiot, megírtad az
                első önálló alkalmazásaidat, saját Activity-ket hoztál létre, használatba vetted a rezgőmotort
                és három különböző érzékelőt is. Ehhez meg kellett tanulnod a layout szerkesztő használatát és
                a Java nyelv alapjait. Gratulálunk!</p>
            <p>
                Az új év <em>(eredetileg januári lecke)</em> viszont most új kihívásokat tartogat. Ahhoz,
                hogy tényleg otthonosan tudjatok mozogni az androidos alkalmazás fejlesztés világában,
                kicsit komolyabb programok felé fordítjuk a figyelmünket.</p>
            <p>
                Az egyik fontos változás, hogy nem fogunk minden leckében új programot készíteni;
                például a mostani leckével egy három leckén átívelő projektbe kezdünk. Ami viszont
                reményeink szerint nem fog változni: minden lecke végén egy használható alkalmazás
                lesz a kezetekben, legfeljebb nem lesz teljesen készen.</p>
        </section>


        <section id="lesson-goal">
            <h2>Tehát akkor a tervezett program</h2>
            <p>
                Az első nagyobb projektben szeretnénk valami olyan programot alkotni, ami hasznosnak
                bizonyulhat akár a mindennapokban is. Az angolórák/nyelvórák pedig elég fontos részét
                képezik a mindennapjainknak; ezen belül pedig mi egészen pontosan a szavak megtanulására
                fogunk összpontosítani.</p>
            <p>
                A mostani leckénk célja nem lesz más, mint egy egyszerű <em>szótárfüzet program</em> megírása.
                Az applikáció készítése közben megismerkedünk majd a listákkal és azok megjelenítésével,
                négy Activity-vel zsonglőrködünk egyszerre, ezáltal tényleg megtapasztalva az igazi
                Android fejlesztés nehézségeit. A végeredmény viszont egy teljes, használható
                applikáció lesz (puskázó appal kombinálva kéretik tanóra keretein belül nem használni!)</p>

            <h3>A program részei</h3>
            <p>
                Az általunk tervezett program négy Activity-ből fog állni. Ennek a gyorsan
                rajzolt (wireframe) terveit itt láthatjátok. Javasoljuk, hogy ismerkedj meg az
                ábrán szereplő ablakokkal, és vagy másold le, vagy térj vissza ide minden
                alkalommal, mielőtt munkához látsz. <em>A kép kattintással nagyítható</em></p>
            <p>
                <img src="/static/img/l08/wireframe.png" class="center-block" />
             </p>
            <ul>
                <li>
                    <strong>Szavak (SzavakActivity)</strong><br/>
                    Kulcsfontosságú része az alkalmazásnak. Itt listázzuk majd ki a szavakat.</li>
                <li>
                    <strong>Kvíz (KvizActivity)</strong><br/>
                    Ez az Activity segít majd minket a nyelvtanulásban. A program véletlenszerűen
                    kérdez tőlünk szavakat</li>
                <li>
                    <strong>About (AboutActivity)</strong><br/>
                    A 6. leckéhez hasonlóan egy egyszerű kis Activity, ami rólad, azaz a program
                    készítőjéről ad egy kicsit több információt (pl. név, email cím stb.)</li>
                <li>
                    <strong>Menü (MenuActivity)</strong><br/>
                    Egy ekkora programnak kell egy kezdőképernyő, ahonnan a különböző ablakokra
                    navigálhatunk. Pofon egyszerű, három gomb, három click függvény, ami a
                    megfelelő Activity-t hívja meg.</li>
            </ul>
            
            <p>
                Ebben a leckében a menü és az About ablakok elkészítése mellett szeretnénk
                letenni a SzavakActivity alapjait a szavak kilistázásával. A következő két leckében ezt fogjuk tovább
                finomítani, illetve megírjuk a <code>KvizActivity</code> ablakot is.</p>
            
            <h3>Honnan jönnek a szavak?</h3>
            <p>
                Egy szótárfüzet programnál jogosan merül fel a kérdés: honnan jönnek a szavak?
                Ebben a leckében a szavakat a program készítésekor kell majd beírnunk (például
                egy tömbbe), részleteket lásd később. </p>
            <p>
               A folytatásban viszont már fájlokat fogunk
                használni, amiket akár számítógépen is szerkeszthettek, illetve egymással vagy
                akár osztálytársakkal is megoszthattok. Egy
                <a href="/static/files/dict1.txt" target="_blank">minta fájl</a> különböző nehézségű szavakkal.
                Ennek kapcsán javasolnánk, hogy mindenki olyan szavakat írjon be (mind a programba,
                mind a fájlokba), amelyek az órákon szükséges nyelvi tudását tükrözik. Így hasznosabb lesz a program,
                mint ha a mi fantáziátlan példáinkat használjátok.</p>
        </section>

        <section id="new-project">
            <h2>Új projekt létrehozása</h2>
            <p>
                Az előző leckéhez hasonlóan most sem készítettünk elő projektet, így azt Nektek
                kell létrehozni. Kicsit lusták is vagyunk, és nem szeretjük ismételni magunkat,
                ezért nem írnánk le megint az új projekt létrehozásának menetét, kövessétek az
                <a href="/lessons/l07.html#new-project" target="_blank">előző leckében leírtakat</a>!
                <em>Az "Importálás helyett…" rész mind a <strong>nyolc</strong> pontját
                figyelmesen csináljátok végig!</em> Amire figyelj:</p>
            <p>
                Alkalmazás adatai</p>
            <ul>
                <li>
                    <strong>Application name:</strong> <code>Szotar</code></li>
                <li>
                    <strong>Project location:</strong> Célszerűen a korábbi projektek mellé érdemes létrehozni,
                    például egy L08-Szotar mappába (pl.: <code>C:\DkrmgAndroid\L08-Szotar</code>)</li>
                <li>
                    <code>API 19</code> kiválasztása</li>
                <li>
                    A varázslóval a kiinduló activity-t is létre kell hozni, ennek neve
                    legyen <code>MenuActivity</code>.</li>
            </ul>
            <p>
                Ne felejtsd el beállítani a megfelelő SDK verziót, majd futtasd a programot a telefonodon!</p>
        </section>


        <section id="menu-activity">
            <h2>Menü (MenuActivity)</h2>
            <p>
                Bemelegítésként rendezzük be a MenuActivity ablakunkat.</p>
            <p>
                <img src="/static/img/l08/menu.png" class="center-block" />
            </p>
            <p>
                Ez a menü ablak tényleg pofon egyszerű. Összesen három gombra lesz csak szükségünk,
                melyek a megfelelő Activity-ket nyitják meg. A megnyitás kódját egyelőre nem tudjuk
                megírni (ehhez hiányozik a maradék három Activity).</p>
            <p>
                Amit már most meg tudunk csinálni:</p>
            <ul>
                <li>
                    A RelativeLayout komponensünknek is állítsuk be az <code>id</code> tulajdonságát például
                    root értékre (később sok fejfájástól óvhat meg minket)</li>
                <li>
                    Három gomb elhelyezése a layout szerkesztőben. Ezeket rendezzük középre, és
                    írjuk be a megfelelő szövegeket az ábra alapján.</li>
                <li>
                    Ezek után az activity kinézetét ízlés szerint formázhatjuk színekkel,
                    betűtípusokkal, vagy képekkel. (utóbbihoz a hetedik lecke
                    <a href="/lessons/l07.html#import-image">megfelelő része</a> nyújthat segítséget</li>
                <li>
                    Minden gombnak legyen egy saját kattintást kezelő függvénye. A kattintáskor
                    lefutó részt még nem tudjuk megírni, így a függvény törzsét üresen fogjuk hagyni. Pl.
<pre>public void buttonSzavakOnClick(View v)  {
    // TODO: a SzavakActivity megnyitása
}</pre>
                <p>
                    A függvényeinket sorban fejezzük be, ahogy a többi Activity-k készülnek.</p>
            </ul>
        </section>


        <section id="about-activity">
            <h2>Ismétlés: AboutActivity</h2>
            <p>
                Ismétlés a tudás anyja, mondták már sokan, és milyen igazuk van! Ismételjünk most mi
                is egy kicsit. A 6. lecke (Iránytű) <a href="/lessons/l06.html#newActivity" target="_blank">végén</a>
                létrehoztunk egy második Activity-t, ami a készítő nevét tartalmazta. Csináljunk egy
                ilyen About Activityt ehhez az alkalmazáshoz is. Annak örülnénk a legjobban, ha minél
                több eszetekbe jutna, de persze ha elakadtok szabad puskázni a 6. lecke leírásából.</p>
            <p>
                <img src="/static/img/l08/about.png" class="center-block" />
            </p>
            <p>
                A lépések nagy vonalaiban:</p>
            <ul>
                <li>
                    Új Blank Activity létrehozása (<em>New -> Activity -> Blank Activity</em>)</li>
                <li>
                    Activity neve: AboutActivity</li>
                <li>
                    Layout szerkesztővel alakítsuk ki az új activity-t (activity_about.xml) tetszés szerint</li>
                <li>
                    Írjuk be azt a két soros kódot, ami megnyitja az About ablakunkat. Mivel az
                    AboutActivity-t a menüből akarjuk megírni, ezért ez a menü ablakunk Java kódjába
                    kell, hogy kerüljön, az egyik gombkattintást kezelő függvénybe azok közül, amit
                    az előző pontban hoztunk létre.</li>
            </ul>
            <p>
                A kód, amely elindítja az AboutActivity-t:</p>
<pre>public void aboutOnClick(View v) {
    Intent intent = new Intent(this, AboutActivity.class);
    startActivity(intent);
}</pre>
            <p>
                Ehhez a feladathoz tartozik egy <a href="#starred_about_menu">szorgalmi</a> is, amiben a gombot felváltja
                egy felbukkanó menü. Az érdekesség kedvéért javasoljuk, hogy a következő lecke előtt
                nézd majd meg!</p>
        </section>


        <section id="szavak-activity">
            <h2>Még egy activity: SzavakActivity</h2>
            <p>
                <em>Első megközelítés</em></p>
            <p>
                <img src="/static/img/l08/szavak.png" class="center-block" />
            </p>
            <p>
                Szuper, most már van egy "névjegy" activity-nk (AboutActivity) és egy kiinduló menü
                activitynk, ahonnan az alkalmazás funkciói lesznek elérhetőek. Ideje elkészítenünk
                az első funkciót, a szavak kilistázását! A cél tehát: egy Activity, ami megjeleníti a
                program által ismert szavak listáját.</p>
            
            <h3>Üres Activity létrehozása, megnyitása</h3>
            <p>
                A fentiek mintájára adjunk hozzá a projekthez még egy activity-t (puska
                <a href="/lessons/l06.html#newActivity" target="_blank">itt</a>) <code>SzavakActivity</code> néven, aminek
                a típusa legyen továbbra is <em>Blank Activity</em>!</p>
            
            <p>
                Most, hogy már többször is beírtátok/bemásoltátok az új activity-t megnyitó kódot,
                nézzük meg kicsit közelebbről ezt a két sort!</p>
<pre>public void aboutOnClick(View v) {
    Intent intent = new Intent(this, ValamiActivity.class);
    startActivity(intent);
}</pre>
            <p>
                Az első sorban létrehozott <code>Intent</code> típusú változónk tárolja, hogy melyik Activity-t
                szeretnénk megnyitni. Írd át úgy a parancsot, hogy SzavakActvity-t nyissa meg!
                <button data-target="help_open_SzavakActivity" class="help-link">Katt a megoldáshoz!</button></p>
            <div class="help-container" id="help_open_SzavakActivity">
<pre>
Intent intent = new Intent(this, SzavakActvity.class);
startActivity(intent);</pre>
            </div>
            
            <h3>Szavak tárolása</h3>
            <p>
                Futólagos ismeretséget köthettünk már az előző leckék során a <code>String</code>
                típussal. Emlékeztetésként: ez egy olyan típus, amely szövegeket tárol. Például
                nézzük meg az alábbi változót:</p>
<pre>String szoveg;
szoveg = "kutya";</pre>
            <p>
                A String típus azonban ennél sokkal többre is képes. A szöveg tartalmazhat szóközöket,
                illetve akár (végre valahára) ékezetes karaktereket is! Például:</p>
<pre>String szoveg2;
szoveg2 = "Ez egy szép kis árvíztűrő tükörfúrógép";</pre>
            <p>
                Innen jön az ötlet: egy magyar-angol szópárt könnyedén eltárolhatunk egy
                String típusú változóban:</p>
<pre>szo1 = "kutya = dog";
szo2 = "macska = cat";</pre>
            <p>
                Azonban a mi programunk remélhetőleg rengeteg szót tárol majd, és mi nem 
                igazán szeretnénk minden szóhoz új változót létrehozni.
                A megoldás, hogy az előző leckében tanult tömböket alkalmazzuk. Tehát:</p>
            <p>
                <strong>A szavainkat egyelőre egy <code>String</code> típusú tömbben fogjuk tárolni.</strong>
                <a href="/lessons/l07.html#arrays" target="_blank">Emlékeztetésként</a>, a String tömb egy olyan
                adatszerkezet, amelynek minden eleme egy String típusú változó.</p>
            <ul>
                <li>
                    Hozzunk is létre egy <code>szavak</code> nevű, String tömb (<code>String[]</code>) típusú
                    változót a <code><strong>SzavakActvity</strong></code>-n belül. Az onCreate függvényben pedig töltsük fel adatokkal.
                    Figyeld meg, hogy a tömbünket első használat előtt a <code>new</code> szóval létrehozzuk,
                    majd kapcsos zárójelek között felsoroljuk, hogy kezdetben milyen Stringek legyenek az elemei.<br/>
                    <pre>szavak = new String[] {"kutya = dog", "macska = cat", "molylepke = moth"};</pre>
            </ul>
            <p>
                A fentiek alapján akárhány Stringet (szöveget) megadhatunk kettősidézőjelek (<code>"</code>)
                között, vesszővel elválasztva. Például: </p>
            <pre>
szavak = new String[] { "kutya = dog", "macska = cat", "ló = horse", "tehén = cow", "állat = animal",
                        "iskola = school", "osztály = class", "osztályterem = classroom", "ceruza = pencil",
                        "vonalzó = ruler", "gondol = think", "érez = feel", "szeret = like", "ad = give",
                        "kap = get", "ékesszólás = eloquence", "kétkedő = incredulous", "egyszerű = trivial",
                        "elkeseredés = exasperation", "győzedelmes = triumphant" };</pre>
            <p>
            Vedd elő a saját szótárfüzetedet, és írj is be néhány olyan szót, amit Neked kell megtanulnod!
            </p>
            <h3>Egy String tömb megjelenítése</h3>
            <p>
                Az eddigi programjaink során több layout komponenssel is találkoztunk már.
                Rengeteg gombot és feliratot hoztunk létre, és a képeket tároló ImageView
                sem teljesen ismeretlen számunkra. Ezúttal azonban egy olyan összetett komponensre
                lesz szükségünk, ami szavak/szövegek egy egész listáját tudja megjeleníteni. Ehhez
                fogjuk használni a <code>ListView</code> vezérlőt.</p>
            <p>
                A most bemutatásra kerülő <code>ListView</code> egy elég különös, univerzális elem,
                ami kicsit másképp viselkedik, mint a korábbi komponenseink. Ügyelnünk kell arra,
                hogy most nem elég csak a layout szerkesztőben kattintgatni ahhoz, hogy  String tömbünk
                elemei megjelenjenek a listában. A Java kódba is kicsit jobban bele kell másznunk.</p>
            <p>
                <img src="/static/img/l08/adapter1.png" class="center-block" />
            </p>
            <h3>Layout kialakítása</h3>
            <p>
                Kezdésként helyezzünk el egy ListView komponenst a layout szerkesztőben (Containers kategória alatt).
                Az Activity legfontosabb feladata a szavak megjelenítése, tehát méretezzük úgy a listánkat,
                hogy a képernyő nagy részét elfoglalja.</p>
            <div class="imgstore">
                <img src="/static/img/l08/listview1.png" class="center-block" />
                <img src="/static/img/l08/listview2.png" class="center-block" />
            </div>
            <p>
                Láthatjuk, hogy a layout szerkesztőnknek fogalma sincs, hogy mit szeretnénk a
                listánkban megjeleníteni, így jobb híján az "item 1", "item 2", … szavakat használja.
                Ezeket fogjuk lecserélni a saját szavainkra.</p>
            <p>
                Mielőtt megnézzük a String tömb megjelenítéséhez szükséges <em>mágikus parancsot</em>, 
                hozzunk létre egy <code>ListView</code> típusú változót a SzavakActivity-ben, mondjuk <code>szolista</code>
                néven, és rendeljük hozzá a ListView komponensünkhöz (ilyet már sokszor csináltunk a
                <code>findViewById</code> paranccsal)! <em>Ugye adtál id-t a ListView komponensnek?</em></p>
            
            <h3>Tömb megjelenítése a ListView komponensen (Adapter)</h3>
            <p>
                Tehát jelenleg a szavaink egy String tömbben laknak, és ezeket szeretnénk megjeleníteni
                a ListView komponensünkön. Nézzük meg az alábbi két sort, majd írjuk be az onCreate
                függvényünk végére.</p>
<pre>ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, szavak);
szolista.setAdapter(adapter);</pre>
            <p>
                Nem kell teljességgel értenünk a fentieket; így is láthatjuk, hogy létrehoztunk egy
                átalakítót (adaptert), ami segít a tömbünket a szolista (<code>ListView</code>) számára megemészthető
                formába hozni. Egészen pontosan létrehoztunk egy úgynevezett ArrayAdapter objektumot,
                ami szól a ListView változónknak: itt vannak az új adatok a <code>szavak</code> tömbben,
                jelenítsd meg őket!</p>
            <p>
                <img src="/static/img/l08/adapter2.png" class="center-block" />
            <p>
                Ha esetleg kicsit megkavarodtál, most még gyorsan ellenőrizheted, hogy hogyan kéne az
                onCreate függvénynek kinéznie:
                <button data-target="help_onCreate_final" class="help-link">Katt ide!</button></p>
            <div class="help-container" id="help_onCreate_final">
                <pre data-include="/include/l08/onCreate_final.java.html"></pre>
            </div>
            <p>
                Futtassuk le a programot. Ha minden igaz, akkor a Menüből a megfelelő gombra kattintva
                eljutunk a Szavak activity-re, ahol ott sorakoznak a kódban megadott szavak.</p>
        </section>


        <section id="szo-objektum">
            <h2>Szavak tárolása</h2>
            <em>Kicsit jobb megközelítés</em>
            <p>
                A programunk ugyan szépen működik, gyönyörűen kilistázza a String értékeket. Ha csak
                ennyit szerettünk volna, akkor most kényelmesen hátradőlhetnénk, elfogyasztva a
                karácsonyról maradt bejglit (ha még nem száradt ki teljesen).</p>
            <p>
                Ahhoz azonban, hogy továbbhaladjunk, egy kicsit sajnos át kell alakítanunk, hogy miként
                tároljuk a szavakat.</p>
            <p>
                Emlékeztetésként: egy szópárt (magyar-angol) egy String-ben került tárolásra
                <code>"magyar = angol"</code> formában. Tehát például:</p>
                <pre>"küklopsz = cyclops", "szem = eye", stb.</pre>
            <p>
                Ez egy igen rugalmatlan módszer. Néhány példa, hogy miért <strong>nem</strong> szeretnénk így tárolni a szópárokat:</p>
            <ul>
                <li>
                    Nagyon bonyolult lenne elérnünk, ha azt szeretnénk, hogy a szavak fordított
                    sorrendben jelenjenek meg ("angol = magyar"). Mégpedig egy szótár programban miért
                    ne lehetne ezt könnyedén elérni?</li>
                <li>
                    Hogy adnánk hozzá szépen mondjuk egy harmadik nyelvet? Van, aki németül/franciául/olaszul is tanul!</li>
                <li>
                    Macerás lenne lecserélni az <code>=</code> jelet mondjuk egy nyílra (<code>--&gt;</code>)</li>
                <li>
                    Hogy nyerhetjük ki egy ilyen Stringből ("magyar = angol") csak az egyik nyelvű szót?
                    Erre szükségünk lesz pedig a kvíznél! És mi lenne, ha hirtelen szeretnénk egy
                    harmadik nyelvet is?</li>
            </ul>
            <p>
                A fenti problémára több megoldás is létezik. Korábbi programozási nyelveknél előfordult,
                hogy például az angol szavakat és a magyar szavakat külön-külön String tömbben tárolták.
                Mi ehelyett egy Java programozók által kedveltebb megoldást választunk.</p>
            <p>
                A lecke folytatásában betekintés szintjén megismerkedünk a Java nyelvben méltán
                népszerű <em>osztály</em> fogalmával. Itt előre szeretnénk leszögezni, hogy ez a
                téma túl nagy egy ilyen leckéhez (vagy akár szakkörhöz); a lecke végén a célunk az
                lenne, hogy mindenki megértse magát az <em>alap ötletet</em>, és lássa, hogy miként
                alkalmazzuk mindezt a szavaink tárolásához. Ne aggódj, ha nem értesz minden részletet.
                Emellett szeretnénk megjegezni, hogy Lazarus nyelvből a <code>class</code> vagy
                <code>record</code> adatszerkezetek ismerete óriási előnyt jelenthet.</p>
            
            <h3>Osztály</h3>
            <p>
                Az osztály egy igen érdekes adatszerkezet, ami segítségével létrehozhatjuk a saját
                változó típusainkat a Java nyelvben. Egészen pontosan amikor megírunk egy osztályt,
                akkor azzal felvázoljuk</p>
            <ul>
                <li>
                    a szerkezetben tárolható adatokat</li>
                <li>
                    és a rajtuk elvégezhető cselekvéseket.</li>
            </ul>
            <p>
                Példaként megnézhetjük a Haromszog osztályt, ami tartalmazza egy háromszög adatait,
                és felvázolja, hogy milyen "cselekvéseket" végezhetünk egy háromszöggel.</p>
            <ul>
                <li>
                    Adatok lehetnek: a,b,c, azaz a három oldal hossza</li>
                <li>
                    cselekvések lehetnek pl. egy függvény, ami kirajzolja a háromszöget a képernyőre,
                    kinyomtatja egy papírra, vagy csak kiszámolja nekünk a háromszög területét, vagy
                    kerületét.</li>
            </ul>
            <p>
               <img src="/static/img/l08/tri.png" class="center-block" />
            </p>
            <p>
                Fontos, hogy mi ezzel egy <em>tervrajzot</em> készítünk csak, azt mondjuk el a Java
                nyelvnek, hogy egy háromszög típusú változó milyen adatokat tároljon. Nem egy bizonyos
                háromszögről van szó! Viszont innentől kezdve akárhány <em>Haromszog típusú változót</em> létre
                tudnánk hozni, amelyek mind a külön-külön a megfelelő adatokat tárolnák, és ki tudnák számolni
                például a saját kerületüket.</p>
            <p>
                A háromszög osztályt itt és most nem írjuk meg (bár javasoljuk, hogy az érdeklődő
                kedvűek olvassanak utána a Java osztályoknak és írják meg az osztály kódját).
                Ehelyett inkább nézzük meg, hogy miként festene egy osztály, ami egy szót tartalmaz,
                különböző nyelveken!</p>
            <p>
                Tehát a két kérdés, amit fel kell tennünk magunknak:</p>
            <ul>
                <li>
                    Milyen adatot tároljon a <code><strong>Szo</strong></code> típus?</li>
                <li>
                    Milyen cselekvések/függvényeket kell elvégeznie ennek a típusnak?</li>
            </ul>
            <p>
                A válaszokat most mi adjuk meg:</p>
            <ul>
                <li>
                    A Szo típusnak legalább két adatot kell tárolnia: a szó angol és magyar formáját.
                    Később ez több nyelvvel is kiegészíthető.</li>
                <li>
                    Az egyetlen fontos cselekvés, amit elvárunk a Szo osztálytól, hogy a tartalmát
                    egyetlen String-ben is ki tudja írni. Ez szükséges ahhoz, hogy ki tudjuk írni a
                    tartalmát a LitstView-ba, az eddig ismertetett módon.</li>
            </ul>
            <p>
                Vágjunk is bele. Hozz létre egy új osztály <code>Szo</code> néven!</p>
            <div class="imgstore">
                <img src="/static/img/l08/newClass1.png" class="center-block" />
                <img src="/static/img/l08/newClass2.png" class="center-block" />
            </div>
            <p>
                Most pedig másold be az alábbi kódot a <code>package...</code> sor alá, felülírva az Android Studio által írt sorokat:</p>
<pre>public class Szo {
    public String magyar;
    public String angol;

    @Override
    public String toString() {
        String sor = magyar + " = " + angol;
        return sor;
    }

    public Szo(String magyar, String angol) {
        this.magyar = magyar;
        this.angol = angol;
    }

    public Szo() {}
}</pre>

            <div id="interactive-class" class="interactive clearfix">
                <div id="panels-container">
                    <div class="interactive-panel">
                        <pre data-include="/include/l08/Szo.java.html"></pre>
                    </div>
                </div>
                <div id="description" class="description" style="float: left; width: 48%;">
                    <p class="selected" data-iid="default">Kattints rá balra a zöld keretes részekre,
                        hogy megtudd, mire valók!</p>
                    <p data-iid="class-name">Ez az új osztályunk neve: <code>Szo</code>. Figyeld meg, hogy az osztály neve
                        megyegyezik a Java fájléval (Szo.java) </p>
                    <p data-iid="fields">A <code>Szo</code> típusunknak két adatot kell tárolnia: a szó angol és magyar formáját.
                        Ezek a <code>Szo</code> osztály belső változói. De ilyesmit mintha már láttunk volna! Igen,
                        ez pontosan olyan, mint amit az Activity elején szoktunk csinálni amikor
                        létrehozunk egy változót valamelyik komponensnek vagy mint a 3. leckében a tippelt
                        számnak. Tehát az angol és a magyar egy-egy változó, mégpedig String típusú. És mivel
                        az osztályunkon belül találhatóak, ezért <strong>belső változó</strong>nak fogjuk hívni őket.</p>
                    <p data-iid="tostring">Ez a belső függvény való arra, hogy egy <code>Szo</code> típusú változót majd
                        szöveggé tudjunk alakítani. Nézd meg, hogy ez a belső függvény hogyan használja a belső változókat!
                        Ez is ismerős lehet egyébként, egy függvény, mégpedig egy <strong>belső függvény</strong>,
                        hiszen ez is az osztályon belül található. Látszik rajta, hogy a neve toString. Java
                        nyelven ez a toString függvény használható arra, hogy egy osztályt szöveggé alakítsunk.</p>
                    <p data-iid="constructor">Ez is egy függvény, ami egészen pontosan abban segít, hogy létre tudjunk
                        hozni új <code>Szo</code> típusú változókat. Tehát amikor azt írod, hogy <code>new Szo("macska", "cat")</code>,
                        akkor ez a függvény fut le. Az ilyen belső függvényeket <em>konstruktor</em>nak hívjuk.
                        Egyelőre ne fájjon miatta a fejed túlzottan.</p>
                    <p data-iid="default-constructor">Ez is egy konstruktor, vele sem kell egyelőre foglalkozni. Azért hagytuk itt,
                        hogy segítsen később a munkában. </p>
                </div>

                <script type="application/javascript">
                    $('#panels-container').on('click', 'span.ih', function () {
                        var iid = $(this).data('iid');
                        $('span.ih').removeClass('selected');
                        $('span.ih[data-iid="' + iid + '"]').addClass('selected');

                        $('.interactive #description p').hide();
                        $('.interactive #description p[data-iid="' + iid + '"]').show();
                    });
                </script>
            </div>
            <img src="/static/img/l08/class.png" class="center-block" />
            <p>
                <strong>Fontos!</strong></p>
            <p>
                Amint már utaltunk rá, az osztály, amit a fenti kóddal adunk meg, az
                <em>csak egy tervrajz</em>! Megmondja, hogy hogyan kell kinéznie egy Szo-nak.
                Ezzel csak egy új típust hoztunk létre. Ahhoz, hogy igazán használni tudjuk, el kell
                kezdenünk Szo típusú változókat gyártani. Ez a következő kóddal tehetjük meg:</p>
<pre>Szo kutya;      // változó deklarálása
kutya = new Szo();   // új, üres szó létrehozása</pre>
            
            <p>
                Ilyenkor létrejön az új változónk. Ha be szeretnénk írni a kutya változó magyar és
                angol megfelelőit, akkor azt könnyedén megtehetjük:</p>
<pre>kutya.magyar = "kutya";
kutya.angol = "dog";</pre>
            <p>
                Láthatjuk, hogy a kutya mögé helyezett ponttal a kutya változónk belső változóinak
                adhatunk értéket (vagy olvashatjuk ki őket).</p>
            <p>
                Mi most még ezen felül csalhatunk is egy kicsit, hogy ne kelljen három sort gépelni,
                beírhatjuk az alábbit is:</p>
<pre>Szo kutya;                  // változó deklarálása
kutya = new Szo("kutya", "dog"); // új szó létrehozása</pre>
            <p>
                Vagy ha még messzebb akarunk menni, akkor mindez egy sorba is leírható!</p>
            <p>
<pre>Szo kutya = new Szo("kutya", "dog"); // változó deklarálása <strong>ÉS</strong> új szó létrehozása</pre>

            <h3>Belső függvény</h3>
            <p>
                Láthattuk, hogy a kutya változó mögé helyezett ponttal a kutya változóban lévő Szo típusú objektum
                belső változóihoz
                nyertünk hozzáférést (pl. kutya.angol, kutya.magyar). Ehhez hasonlatosan nem nehéz
                kitalálni, hogy a <code>kutya.toString()</code> parancs meghívja a kutya változóban lévő Szo típusú
                objektum toString
                belső függvényét. Ha megnézed a Szo osztály kódját, akkor láthatod, hogy az az alábbi
                Stringet fogja nekünk visszaadni: "kutya = dog". Ha létrehozunk egy macska változót is
                (<code>macska =new Szo("macska", "cat");</code>), akkor a <code>macska.toString()</code>
                parancs pedig nem túl meglepő módon a "<code>macska = cat</code>" Stringet fogja visszaadni.
                Eddig nem foglalkoztunk mélyrehatóan a függvények működésével, így nem probléma, ha ezt nem
                látod át teljesen.</p>
        </section>



        <section id="tomb-sajat-objektummal">
            <h2>Tömb átalakítása saját objektumossá</h2>
            <p>
                A szólistánkat eddig egy tömbben tároltuk. Egy olyan tömbben, ami egyszerű Stringekből állt.
                Talán nem túl meglepő lépés, hogy most szeretnénk ezt a tömbünket kicsit átalakítani, és egy
                olyan tömböt használni inkább, amelynek minden eleme <code>Szo</code> típusú.</p>
            <p>
                Ha visszaemlékeztek, a lecke elején csináltunk egy tömböt, ami String-eket tudott tárolni,
                és ezeket jelenítettük meg a <code>ListView</code>-ban. Ezt a String tömböt így deklaráltuk
                az Activity kódjának elején.</p>
<pre>String[] szavak;</pre>
            <p>
                Figyeld meg, hogy mi mit jelent/jelez! Először leírjuk, hogy milyen típusú objektumokat
                szeretnénk belerakni, majd a <code>[]</code> karakterekkel megmondjuk, hogy nem egyet,
                hanem többet szeretnénk tárolni a változóban. Utána már csak a változó nevét
                kell megadni (itt pl. "szavak"). Eddig egy változóba csak egy objektum fért, de ha a <code>[]</code>ket
                is használjuk, akkor már több is belefér egymás mellé. Ilyenkor tömb-nek hívjuk.</p>
            <p>
                De mi azt szeretnénk, hogy ne String-eket, hanem Szo objektumokat tároljon a tömbünk.
                Ezt hogyan tudnád elérni?
                <button data-target="help_Szo_array" class="help-link">Segítség</button></p>
            <div class="help-container" id="help_Szo_array">
                <pre>Szo[] szavak;</pre>
            </div>
            <p>
                Ha a tömbünk típusát átírtuk, akkor a benne lakó adatokat is meg kell változtatni
                egy csöppet. Az Android Studio most aláhúzza azt a sort, ahol a "macska&nbsp;=&nbsp;cat",
                "kutya&nbsp;=&nbsp;dog", "molylepke&nbsp;=&nbsp;moth" szópárokat bepakoltuk a tömbbe. Mindezt teljesen
                jogosan teszi, hiszen a szavak tömbbe most már nem Stringeket, hanem Szo típusú
                változókat kéne tenni.</p>
            <ul>
                <li>
                    Ehhez vagy minden szónak kell csinálni egy új változót. Pl.
<pre>
Szo cica = new Szo("cica", "cat");
Szo kutya = new Szo("kutya", "dog");
…
szavak = new Szo[]{kutya, cica, molylepke};</pre></li>
                <li>
                    Vagy az egyszerűség kedvéért írhatjuk ezt is:
<pre>szavak = new Szo[] {new Szo("kutya", "dog"), new Szo("macska", "cat"), new Szo("molylepke", "moth") };</pre></li>
            </ul>
            <p>
                Már csak annyi feladatunk van, hogy az adaptert is átállítsuk, hogy ne String-eket használjon,
                hanem Szo típusú változókat. Ehhez keresd meg azt a részt, ahova ezt beírtad (onCreate):</p>
            <p>
<pre>ArrayAdapter&lt;<strong>String</strong>&gt; adapter = new ArrayAdapter&lt;<strong>String</strong>&gt;(this, android.R.layout.simple_list_item_1, szavak);</pre>
            <p>
                És ahol <strong>String</strong>-et látsz, írd át <strong>Szo</strong>-ra
                (2 helyen van, ezeket kiemeltük)!</p>
            <p>
                Ezzel készen is vagyunk, ki lehet próbálni a programot! Ha mindent jól csináltál,
                akkor ugyan azt kell látnod, mint amikor String-ek voltak a tömbben! Mindez annak
                köszönhető, hogy a ListView (egészen pontosan az adapter) a Szo típusunk kiírásához
                rögtön a toString() függvény segítéségét kéri. Tehát a ListView minden egyes Szo-nak
                meghívja a saját toString-jét. És mivel mi úgy írtuk meg a Szo toString függvényét,
                hogy "angol = magyar" formába alakítsa szöveggé a Szo-t pontosan ezt is fogjuk látni a listánkban.</p>
            <p>
                És hogy mégis miért szenvedtünk ennyit az osztályunk megírásával?</p>
        </section>
        <section id="tasks">
            <h4 class="task">1. Feladat</h4>
            <p>
                Változtasd meg úgy a Szo osztály <code>toString()</code> belső függvényét, hogy a
                szavak közé egyenlőségjel helyett kötőjelet tegyen inkább!
                <button data-target="help_task1" class="help-link">Segítség</button></p>
            <p>
            Futtasd a programot! Minden szónál kötőjel jelenik most már meg?
            </p>
            <div class="help-container" id="help_task1">
                <pre>String sor =  magyar + " <strong>=</strong> " + angol;</pre>
                Láthatod, hogy a <code>magyar</code> szót, az <code>=</code> jelet és az <code>angol</code> szót hogyan fűzzük 
                egymás után a + jelekkel. Nincs más dolgod, mint lecserélni itt az egyenlőségjelet egy kötőjelre!
            </div>
            
            <h4 class="task">2. Feladat</h4>
            <p>
                Változtasd meg úgy a Szo osztály <code>toString()</code> belső függvényét, hogy a nyelveket
                angol-magyar sorrendben jelenítse meg!
                <button data-target="help_task2" class="help-link">Megoldás</button></p>
            <div class="help-container" id="help_task2">
                <pre>String sor = angol + " <strong>-</strong> " + magyar;</pre>
            </div>
        </section>

        
        <h2>
            Szorgalmi
        </h2>

        <section id="starred_third_language">
            <h3>Harmadik nyelv hozzáadása</h3>
            <p>
                Fentebb említettük, hogy például azért jó, hogy bevezettük az új osztályt, mert könnyebb új
                nyelvet hozzáadni. Csináljuk is meg! Válassz ki egy tetszőleges nyelvet (mi a németet választottuk),
                és gondolkozz el, hogy miket kéne csinálni ahhoz, hogy egy Szo objektum a harmadik nyelven is tudja
                tárolni a szó jelentését! Érdemes lehet visszamenni az
                <a href="#interactive-class">interaktív részhez</a>. Ha végiggondoltad,
                <button onclick="$('#thirdlang_solution').show();">kattints ide</button>, hogy
                megjelenjen a megoldás!</p>
            <div id="thirdlang_solution" style="display: none;">
                <p>
                    Az interaktív részben láthattad, hogy a Szo objektumok <code>public String &lt;nyelv&gt;;</code>
                    belső változókban tárolják az adott nyelvű szavakat. Tehát az első lépés az, hogy felveszünk
                    egy új belső változót, a mi esetünkben így:</p>
                <pre>public String nemet;</pre>
                <p class="task">
                    Ezt a már meglévő két nyelv alá írd be!</p>
                <p>
                    Mostantól a régi módszerrel már megadható a német alakja is a szónak, így:</p>
<pre>Szo kutya;      // változó deklarálása
kutya = new Szo();   // új, üres szó létrehozása
kutya.angol = "dog";
kutya.magyar = "kutya";
<strong>kutya.nemet = "der Hund";</strong></pre>
                <p>
                    Persze jó lenne, ha másik módszer is használható lenne
                    (<code>new Szo("kutya", "dog", <strong>"der Hund"</strong>)</code>). Ehhez a konstruktort is
                    módosítani kell. (Melyik is a konstruktor? Nézd meg az iteraktív részben!)</p>
                <p class="task">
                    Fel kell venni hozzá egy új paramétert:</p>
                <pre>public Szo(String magyar, String angol<strong>, String nemet</strong>) { ...</pre>
                <p class="task">
                    Valamint a konstruktor törzsét is ki kell egészíteni:</p>
<pre>this.magyar = magyar;
this.angol = angol;
this.nemet = nemet;</pre>
                <p>Szuper, most már németül is el tudjuk tárolni a szavak jelentését (persze ehhez át kell írni
                    a tömb feltöltése rész, hogy a német alak is szerepeljen)! De ha most kipróbálod a programot,
                    akkor nem látsz semmilyen változást. Ahhoz, hogy a listában is megjelenjen a német alak,
                    a toString() függvént is módosítani kell. Ezt rád bízzuk!</p>
                <p>A végén így kell kinéznie a Szo osztálynak (csak akkor nézd meg, ha a toString-et is
                    megpróbáltad átírni):
                    <button data-target="help_Szo_3rd_language" class="help-link">A Szo osztály új verziója</button></p>
                <div class="help-container" id="help_Szo_3rd_language">
<pre>public class Szo {
    public String magyar;
    public String angol;
    public String nemet;

    @Override
    public String toString() {
        String sor = magyar + " = " + angol + " = " + nemet;
        return sor;
    }

    public Szo(String magyar, String angol, String nemet) {
        this.magyar = magyar;
        this.angol = angol;
        this.nemet = nemet;
    }

    public Szo() {}
}</pre>
                </div>
            </div>
        </section>

        <section id="starred_about_menu">
            <h3>AboutActivity menüből</h3>

            <p>
                Bizonyára találkoztatok már más alkalmazásokban a "három pont" ikonnal.</p>
            <img src="/static/img/l08/action_bar_pattern_overflow.png" class="center-block" />
            <p>Ez arra jó, hogy bizonyos funkciókat onnan lehet elérni, és nem egy külön gomb van nekik.
                Az About activity megnyitása tipikusan ilyen funkció, mivel elég ritkán használják, de mégis szükséges.
                Csináljunk mi is egy menüt, amivel meg lehet nyitni az AboutActivitynket!</p>
            <ol>
                <li>
                    A <em>res -> menu</em> mappában kell lennie egy menu.xml fájlnak. Ezt nyisd meg!
                    Ez a fájl írja le, hogy <em>hogy nézzen ki</em> a menü. (Pont mint a layout az activitynél.)</li>
                <li>
                    Ebben a fájlban az <code>&lt;item</code> és a <code>/&gt;</code> közötti részben fogunk dolgozni.
                    Ezt a részt írd át, hogy pontosan így nézzen ki! (alatta megnézzük, hogy mi micsoda)
<pre>&lt;item android:id="@+id/open_about" android:title="About"
      android:orderInCategory="100" app:showAsAction="never" /&gt;</pre>
                    Az <code>android:id="@+id/xxxxxxxx"</code> a menü azonosítója, ugyan úgy, mint ahogy
                    a komponenseknek is van.
                    Az <code>android:title</code> rész tartalma (az idézőjelek között) az a szöveg,
                    ami meg fog jelnni, ha megnyomják a 3 pontot.
                    A másik kettővel egyelőre nem foglalkozunk, de akit érdekel utánanézhet! :) <br/>
                    Ha esetleg aláhúzná a app:showAsAction részt, akkor a fájl tetején az xmlns:android="blabla" után írd be ezt:
                    <code>xmlns:app="http://schemas.android.com/apk/res-auto"</code>
                </li>
                <li>
                    Ahhoz, hogy a 3 pontos gomb megjelenjen, az <code>onCreateOptionsMenu</code> függvényt kell megírnunk
                    a MenuActivityben. Előfordulhat, hogy az AndroidStudio már generált ilyet, akkor azt kell
                    módosítani. A lényeg, hogy a végén így nézzen ki:
<pre>@Override
public boolean onCreateOptionsMenu(Menu menu) {
    <strong>getMenuInflater().inflate(R.menu.menu, menu);</strong>
    return super.onCreateOptionsMenu(menu);
}</pre>
                    A kiemelt rész felelős azért, hogy amit megírtunk menu.xml fájl által leírt menü
                    megjelenjen a 3 pont megnyomásakor. (A részletekről szívesen mesélünk, de nem annyira
                    lényeges, ezért most nem mennénk bele a részletekbe.)
                </li>
                <li>
                    Ha most lefuttatod a programot, akkor meg kell jelennie a 3 pontnak a képernyő tetején,
                    és rákattintásra meg kell jelennie egy <code>About</code> feliratnak, amire kattintva
                    nem történik semmi. Persze, hiszen azt még nem írtuk meg, hogy mi történjen ebben az esetben.</li>
                <li>
                    Ehhez az <code>onOptionsItemSelected</code> függvényt kell megírni/módosítani. Ez a
                    függvény akkor hívódik meg, amikor a felhasználó megnyomja valamelyik menüsort.
                    A MenuItem típusú paramétere tartalmazza a megnyomott menüsor adatait, pl. az id-jét.</li>
                <li>Mivel később esetleg lehet több különböző menüsorunk is, az első feladat, hogy megnézzük,
                    hogy melyiket is nyomta meg a felhasználó. <br/> Pédául így:
                    <em><strong>HA</strong> a megnyomott menüsor azonosítója
                        <code>open_about</code>, akkor csináljunk <strong>valamit</strong>
                    </em><br/>
                    Remélhetőleg erről rögtön az if-szerkezet jut eszedbe. Érdemes átnézni
                    <a href="http://goo.gl/VWkLlk" target="_blank">a harmadik lecke 2. pdf-ének 3. oldalán</a>!</li>
                <li>Próbáld meg ezek alapján magadtól megírni, hogy ha az open_about id-jű menüsort
                    nyomták meg, akkor nyissa meg az AboutActivity-t! Kis segítség: a menüsor
                    id-ja így kérdezhető le: <code>item.getItemId()</code> Ha elakadsz, vagy ellenőrzésképp
                    gombnyomás után láthatod a megoldást.
                    <button data-target="help_onOptionsItemSelected" class="help-link">Megoldás</button></p>
                    <div class="help-container" id="help_onOptionsItemSelected">
<pre>if (item.getItemId() == R.id.open_about) {
    Intent intent = new Intent(this, AboutActivity.class);
    startActivity(intent);
}</pre>
                    </div></li>
            </ol>
        </section>


    </div>
    <footer data-include="/include/footer.html"></footer>
    <script src="/include/js/lessonBottomStuff.js" type="text/javascript" charset="utf-8"></script>
    <script src="//cdn.rawgit.com/noelboss/featherlight/master/release/featherlight.min.js"></script>
    <link rel="stylesheet" href="/static/css/stsheet.css" />
</body>
</html>
